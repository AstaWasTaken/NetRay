"use strict";(self.webpackChunknet_ray_docs=self.webpackChunknet_ray_docs||[]).push([[163],{8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>d});var t=r(6540);const i={},a=t.createContext(i);function l(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(a.Provider,{value:n},e.children)}},9157:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>s,contentTitle:()=>d,default:()=>u,frontMatter:()=>l,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"advanced-features/middleware","title":"Middleware","description":"Middleware provides a powerful way to intercept and process network data as it flows through NetRay. You can use it for logging, validation, rate limiting, data transformation, or even blocking events/requests based on custom logic.","source":"@site/docs/advanced-features/middleware.md","sourceDirName":"advanced-features","slug":"/advanced-features/middleware","permalink":"/NetRay/docs/advanced-features/middleware","draft":false,"unlisted":false,"editUrl":"https://github.com/AstaWasTaken/NetRay/docs/advanced-features/middleware.md","tags":[],"version":"current","frontMatter":{"title":"Middleware"},"sidebar":"docsSidebar","previous":{"title":"Advanced Features","permalink":"/NetRay/docs/category/advanced-features"},"next":{"title":"Type Checking","permalink":"/NetRay/docs/advanced-features/type-checking"}}');var i=r(4848),a=r(8453);const l={title:"Middleware"},d="Middleware",s={},o=[{value:"Registration",id:"registration",level:2},{value:"Example: Basic Logger Middleware (runs fairly early)",id:"example-basic-logger-middleware-runs-fairly-early",level:3},{value:"Example: Input Sanitization Middleware (runs later)",id:"example-input-sanitization-middleware-runs-later",level:3},{value:"Example: Blocking Middleware (runs very early)",id:"example-blocking-middleware-runs-very-early",level:3},{value:"Execution Flow",id:"execution-flow",level:2},{value:"Use Cases",id:"use-cases",level:2}];function c(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"middleware",children:"Middleware"})}),"\n",(0,i.jsx)(n.p,{children:"Middleware provides a powerful way to intercept and process network data as it flows through NetRay. You can use it for logging, validation, rate limiting, data transformation, or even blocking events/requests based on custom logic."}),"\n",(0,i.jsx)(n.p,{children:"Middleware functions are executed sequentially based on their priority number (lower numbers run earlier)."}),"\n",(0,i.jsx)(n.h2,{id:"registration",children:"Registration"}),"\n",(0,i.jsxs)(n.p,{children:["Register middleware globally using ",(0,i.jsx)(n.code,{children:"NetRay:RegisterMiddleware()"}),". This works on both the client and the server."]}),"\n",(0,i.jsx)(n.p,{children:"name: A unique string identifier for the middleware.\nhandlerFn: The function to execute. It receives (eventName, player, data).\nplayer: nil on the client or when server fires globally.\npriority: A number (optional, default 100). Lower numbers execute first."}),"\n",(0,i.jsx)(n.h3,{id:"example-basic-logger-middleware-runs-fairly-early",children:"Example: Basic Logger Middleware (runs fairly early)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'NetRay:RegisterMiddleware("GlobalLogger", function(eventName, player, data)\n    local context = game:GetService("RunService"):IsServer() and "Server" or "Client"\n    local playerName = player and player.Name or "N/A"\n    print(`[${context} MW] Event/Request: ${eventName}, Player: ${playerName}`)\n    -- print(data) -- Careful: Printing large tables can lag\n\n    -- IMPORTANT: Middleware MUST return something to continue the chain.\n    -- Return \'data\' (modified or unmodified) to allow processing to continue.\n    -- Return \'nil\' if you didn\'t modify the data (equivalent to returning original \'data\').\n    -- Return \'false\' to block the event/request entirely.\n    return data\nend, 20) -- Priority 20\n'})}),"\n",(0,i.jsx)(n.h3,{id:"example-input-sanitization-middleware-runs-later",children:"Example: Input Sanitization Middleware (runs later)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'NetRay:RegisterMiddleware("Sanitizer", function(eventName, player, data)\n    if eventName == "PlayerChatMessage" and type(data) == "table" and type(data.message) == "string" then\n        -- Basic sanitization example (more robust filtering needed for production)\n        data.message = data.message:gsub("[<>]", "") -- Simple tag removal\n        print("[MW Sanitizer] Sanitized chat message.")\n        return data -- Return the modified data\n    end\n    -- If no changes, return the original data (or nil)\n    return data\nend, 150) -- Priority 150\n'})}),"\n",(0,i.jsx)(n.h3,{id:"example-blocking-middleware-runs-very-early",children:"Example: Blocking Middleware (runs very early)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'NetRay:RegisterMiddleware("MaintenanceModeBlocker", function(eventName, player, data)\n    if game:GetAttribute("MaintenanceMode") == true then\n        -- Don\'t allow any client -> server communication during maintenance\n        if game:GetService("RunService"):IsServer() and player then\n            warn("[MW Blocker] Maintenance mode active, blocking event:", eventName, "from", player.Name)\n            return false -- Block the event/request\n        end\n    end\n    return data\nend, 5) -- Priority 5\n'})}),"\n",(0,i.jsx)(n.h2,{id:"execution-flow",children:"Execution Flow"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"When an event/request is fired or received, NetRay retrieves the list of registered middleware handlers."}),"\n",(0,i.jsx)(n.li,{children:"Handlers are sorted by priority (lowest to highest)."}),"\n",(0,i.jsxs)(n.li,{children:["The initial ",(0,i.jsx)(n.code,{children:"data"})," payload is passed to the first middleware handler."]}),"\n",(0,i.jsxs)(n.li,{children:["Each handler executes and can:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Return the ",(0,i.jsx)(n.code,{children:"data"})," (modified or original): This payload is passed to the next middleware in the chain."]}),"\n",(0,i.jsxs)(n.li,{children:["Return ",(0,i.jsx)(n.code,{children:"nil"}),": Equivalent to returning the unmodified ",(0,i.jsx)(n.code,{children:"data"}),". The chain continues with the same payload."]}),"\n",(0,i.jsxs)(n.li,{children:["Return ",(0,i.jsx)(n.code,{children:"false"}),": Stops the middleware chain ",(0,i.jsx)(n.em,{children:"and"})," blocks the underlying event/request from being processed further (e.g., the ",(0,i.jsx)(n.code,{children:"OnEvent"})," or ",(0,i.jsx)(n.code,{children:"OnRequest"})," handler won't be called, the remote fire won't happen)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["If the chain completes without being blocked, the final resulting ",(0,i.jsx)(n.code,{children:"data"})," payload is used for the actual event/request processing."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Logging:"})," Record network activity for debugging."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Validation:"})," Perform complex validation beyond basic type checking."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Authentication/Authorization:"})," Verify player permissions before processing certain requests (though often better handled in the ",(0,i.jsx)(n.code,{children:"OnEvent"}),"/",(0,i.jsx)(n.code,{children:"OnRequest"})," handler itself for clarity)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Rate Limiting:"})," Implement custom rate limiting logic per player or globally."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Data Transformation:"})," Modify data formats between client/server if needed (e.g., changing property names)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Feature Flags:"})," Enable/disable certain network events based on server configuration."]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{title:"Synchronous Execution",type:"caution",children:(0,i.jsxs)(n.p,{children:["Middleware handlers ",(0,i.jsx)(n.strong,{children:"must execute synchronously"}),". Avoid yielding (like ",(0,i.jsx)(n.code,{children:"wait()"}),", ",(0,i.jsx)(n.code,{children:"task.wait()"}),", or asynchronous API calls like ",(0,i.jsx)(n.code,{children:"DataStoreService:GetAsync"}),") within a middleware function, as this will halt the entire network processing pipeline for that specific event/request. If complex asynchronous checks are needed, they typically belong in the final ",(0,i.jsx)(n.code,{children:"OnEvent"})," or ",(0,i.jsx)(n.code,{children:"OnRequest"})," handler."]})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);