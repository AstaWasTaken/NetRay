"use strict";(self.webpackChunknet_ray_docs=self.webpackChunknet_ray_docs||[]).push([[824],{4697:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>s,metadata:()=>n,toc:()=>o});const n=JSON.parse('{"id":"advanced-features/circuit-breakers","title":"Circuit Breakers","description":"The Circuit Breaker pattern is a crucial technique for building resilient networked systems. It prevents an application from repeatedly trying to execute an operation that\'s likely to fail, especially due to downstream service unavailability or errors. NetRay integrates Circuit Breakers to automatically manage the health of event/request endpoints.","source":"@site/docs/advanced-features/circuit-breakers.md","sourceDirName":"advanced-features","slug":"/advanced-features/circuit-breakers","permalink":"/NetRay/docs/advanced-features/circuit-breakers","draft":false,"unlisted":false,"editUrl":"https://github.com/AstaWasTaken/NetRay/docs/advanced-features/circuit-breakers.md","tags":[],"version":"current","frontMatter":{"title":"Circuit Breakers"},"sidebar":"docsSidebar","previous":{"title":"Type Checking","permalink":"/NetRay/docs/advanced-features/type-checking"},"next":{"title":"Event Priorities","permalink":"/NetRay/docs/advanced-features/priorities"}}');var i=r(4848),a=r(8453);const s={title:"Circuit Breakers"},c="Circuit Breakers",l={},o=[{value:"How it Works",id:"how-it-works",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Example Client-Side Event Registration (client making calls)",id:"example-client-side-event-registration-client-making-calls",level:3},{value:"Key Configuration Options:",id:"key-configuration-options",level:3},{value:"Monitoring",id:"monitoring",level:2},{value:"Manual Control",id:"manual-control",level:2}];function d(e){const t={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"circuit-breakers",children:"Circuit Breakers"})}),"\n",(0,i.jsx)(t.p,{children:"The Circuit Breaker pattern is a crucial technique for building resilient networked systems. It prevents an application from repeatedly trying to execute an operation that's likely to fail, especially due to downstream service unavailability or errors. NetRay integrates Circuit Breakers to automatically manage the health of event/request endpoints."}),"\n",(0,i.jsx)(t.h2,{id:"how-it-works",children:"How it Works"}),"\n",(0,i.jsx)(t.p,{children:"A Circuit Breaker acts like an electrical circuit breaker, wrapping a protected function call (like sending a network request). It operates in three states:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"CLOSED:"})," (Initial State) Requests are allowed to pass through. The breaker counts failures. If the failure count exceeds a threshold within a time window, the breaker trips and transitions to the ",(0,i.jsx)(t.strong,{children:"OPEN"})," state. Successes reset the failure count."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"OPEN:"})," Requests are immediately rejected (or a fallback is executed) ",(0,i.jsx)(t.em,{children:"without"})," attempting the network operation. This prevents overloading a struggling service. After a configured timeout (",(0,i.jsx)(t.code,{children:"resetTimeout"}),"), the breaker transitions to ",(0,i.jsx)(t.strong,{children:"HALF_OPEN"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"HALF_OPEN:"})," A limited number of test requests are allowed through.","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["If these requests succeed consistently (",(0,i.jsx)(t.code,{children:"halfOpenMaxRequests"}),"), the breaker assumes the underlying issue is resolved and transitions back to ",(0,i.jsx)(t.strong,{children:"CLOSED"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:["If ",(0,i.jsx)(t.em,{children:"any"})," test request fails, the breaker trips again, transitioning back to ",(0,i.jsx)(t.strong,{children:"OPEN"})," (often with an increased timeout - adaptive backoff)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsxs)(t.p,{children:["Circuit Breaker behavior is configured ",(0,i.jsx)(t.em,{children:"per event/request"})," within the ",(0,i.jsx)(t.code,{children:"options"})," table during registration."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-lua",children:'-- Example Server-Side Request Registration\r\nlocal externalApiRequest = NetRay:RegisterRequestEvent("CallExternalAPI", {\r\n    circuitBreaker = {\r\n        -- Required settings:\r\n        failureThreshold = 3,  -- Trip to OPEN after 3 consecutive/recent failures\r\n        resetTimeout = 20,    -- Wait 20s in OPEN state before trying HALF_OPEN\r\n\r\n        -- Optional settings:\r\n        fallback = function(player, data)\r\n            warn("External API circuit breaker is OPEN. Returning cached/default data for", player.Name)\r\n            -- Return a default response or nil\r\n            return { status = "cached", data = "Default Value" }\r\n        end,\r\n        halfOpenMaxRequests = 2, -- Allow 2 successful requests in HALF_OPEN to close\r\n        adaptiveTimeouts = true, -- Automatically increase resetTimeout on repeated OPEN transitions (default true)\r\n        minimumTimeout = 10,    -- Minimum resetTimeout value (seconds)\r\n        maximumTimeout = 120,   -- Maximum resetTimeout value (seconds)\r\n        -- healthCheckInterval = 0 -- Interval to try HALF_OPEN early (disabled by default)\r\n    }\r\n})\n'})}),"\n",(0,i.jsx)(t.h3,{id:"example-client-side-event-registration-client-making-calls",children:"Example Client-Side Event Registration (client making calls)"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-lua",children:'local criticalServerAction = NetRay:RegisterEvent("DoCriticalAction", {\r\n    circuitBreaker = {\r\n        failureThreshold = 5,\r\n        resetTimeout = 30,\r\n        fallback = function(data) -- Fallback when Client attempts :FireServer()\r\n            warn("Circuit for \'DoCriticalAction\' is OPEN. Action blocked.")\r\n            -- Maybe show UI feedback? Do nothing?\r\n        end\r\n    }\r\n})\n'})}),"\n",(0,i.jsx)(t.h3,{id:"key-configuration-options",children:"Key Configuration Options:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"failureThreshold"}),": Number of failures required to trip the breaker (default: 5)."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"resetTimeout"}),": Duration (seconds) the breaker stays OPEN before entering HALF_OPEN (default: 30)."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"fallback"}),": (Optional) A function executed ",(0,i.jsx)(t.em,{children:"instead"})," of the network call when the circuit is OPEN. Should match the signature of the intended call (e.g., ",(0,i.jsx)(t.code,{children:"fallback(player, data)"})," for server-side request handler, ",(0,i.jsx)(t.code,{children:"fallback(data)"})," for client event sender). If it returns a value, that value is returned to the caller (useful for requests)."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"halfOpenMaxRequests"}),": Number of successful calls required in HALF_OPEN state to fully close the circuit (default: 1)."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"adaptiveTimeouts"}),": If true (default), ",(0,i.jsx)(t.code,{children:"resetTimeout"})," increases automatically (up to ",(0,i.jsx)(t.code,{children:"maximumTimeout"}),") if the circuit re-opens quickly after entering HALF_OPEN."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"minimumTimeout"}),", ",(0,i.jsx)(t.code,{children:"maximumTimeout"}),": Clamp the effective ",(0,i.jsx)(t.code,{children:"resetTimeout"})," value (used with adaptive timeouts)."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"monitoring",children:"Monitoring"}),"\n",(0,i.jsx)(t.p,{children:"You can access the Circuit Breaker instance for an event/request and monitor its state changes."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-lua",children:'-- Get the breaker instance\r\nlocal cb = NetRay:GetCircuitBreaker("CallExternalAPI")\r\n\r\nif cb then\r\n    -- Check current state\r\n    print("Current State:", cb.State) -- "CLOSED", "OPEN", "HALF_OPEN"\r\n\r\n    -- Connect to state changes\r\n    cb.Signals.StateChanged:Connect(function(oldState, newState)\r\n        warn(("Circuit Breaker \'CallExternalAPI\' changed state: %s -> %s"):format(oldState, newState))\r\n    end)\r\n\r\n    -- Connect to other signals if needed\r\n    cb.Signals.FailureRecorded:Connect(function() print("CB Failure Recorded!") end)\r\n    cb.Signals.Recovered:Connect(function(recoveryTime) print("CB Recovered in", recoveryTime, "s") end)\r\n\r\n    -- Get detailed metrics\r\n    local metrics = cb:GetMetrics()\r\n    print("Total Failures:", metrics.totalFailures)\r\n    print("Open Count:", metrics.openCount)\r\nend\n'})}),"\n",(0,i.jsx)(t.h2,{id:"manual-control",children:"Manual Control"}),"\n",(0,i.jsx)(t.p,{children:"You can force a specific state if needed for testing or administrative purposes."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-lua",children:'-- Get the breaker instance\r\nlocal cb = NetRay:GetCircuitBreaker("MyEvent")\r\nif cb then\r\n    -- Force open for maintenance/testing\r\n    cb:ForceState(CircuitBreaker.State.OPEN) -- Use the internal State enum constant\r\n\r\n    -- Force closed to reset manually\r\n    -- cb:ForceState(CircuitBreaker.State.CLOSED)\r\nend\n'})}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsxs)(t.p,{children:["Note that NetRay's circuit breaker currently tracks failures primarily based on ",(0,i.jsx)(t.em,{children:"network-level"})," or ",(0,i.jsx)(t.em,{children:"handler execution"})," errors (like timeouts in requests, or ",(0,i.jsx)(t.code,{children:"error()"}),' calls within request handlers). It doesn\'t automatically track "logical" failures (e.g., a request completing successfully but returning ',(0,i.jsx)(t.code,{children:"{success = false}"}),"). Logical failures need to be handled in your application code."]})})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,r)=>{r.d(t,{R:()=>s,x:()=>c});var n=r(6540);const i={},a=n.createContext(i);function s(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);