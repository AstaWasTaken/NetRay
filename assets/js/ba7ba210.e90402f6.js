"use strict";(self.webpackChunknet_ray_docs=self.webpackChunknet_ray_docs||[]).push([[293],{888:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"core-concepts/requests","title":"Requests (Request/Response)","description":"Requests in NetRay handle two-way communication where a response is expected, replacing the need for RemoteFunction. They utilize Promises for cleaner asynchronous code flow.","source":"@site/docs/core-concepts/requests.md","sourceDirName":"core-concepts","slug":"/core-concepts/requests","permalink":"/NetRay/docs/core-concepts/requests","draft":false,"unlisted":false,"editUrl":"https://github.com/AstaWasTaken/NetRay/docs/core-concepts/requests.md","tags":[],"version":"current","frontMatter":{"title":"Requests (Request/Response)"},"sidebar":"docsSidebar","previous":{"title":"Events (Fire-and-Forget)","permalink":"/NetRay/docs/core-concepts/events"},"next":{"title":"Advanced Features","permalink":"/NetRay/docs/category/advanced-features"}}');var r=t(4848),a=t(8453);const i={title:"Requests (Request/Response)"},o="Core Concepts: Requests",c={},l=[{value:"Key Features",id:"key-features",level:2},{value:"Server-Side Usage",id:"server-side-usage",level:2},{value:"Registering a Request Event",id:"registering-a-request-event",level:3},{value:"Handling Client Requests",id:"handling-client-requests",level:3},{value:"Invoking Requests on Clients (Server -&gt; Client)",id:"invoking-requests-on-clients-server---client",level:3},{value:"Client-Side Usage",id:"client-side-usage",level:2},{value:"Getting/Registering a Request Event",id:"gettingregistering-a-request-event",level:3},{value:"Making Requests to Server",id:"making-requests-to-server",level:3},{value:"Example Usage (e.g., connected to a Buy button)",id:"example-usage-eg-connected-to-a-buy-button",level:3},{value:"Handling Server Requests (Client -&gt; Server Response)",id:"handling-server-requests-client---server-response",level:3},{value:"Example Request Registration",id:"example-request-registration",level:3}];function u(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"core-concepts-requests",children:"Core Concepts: Requests"})}),"\n",(0,r.jsxs)(n.p,{children:["Requests in NetRay handle two-way communication where a response is expected, replacing the need for ",(0,r.jsx)(n.code,{children:"RemoteFunction"}),". They utilize Promises for cleaner asynchronous code flow."]}),"\n",(0,r.jsx)(n.h2,{id:"key-features",children:"Key Features"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Asynchronous:"})," Uses a ",(0,r.jsx)(n.code,{children:"Promise"})," API (",(0,r.jsx)(n.code,{children:".andThen()"}),", ",(0,r.jsx)(n.code,{children:".catch()"}),", ",(0,r.jsx)(n.code,{children:".finally()"}),") avoiding yields."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type Safety:"})," Define expected structures for ",(0,r.jsx)(n.em,{children:"both"})," the request and response using ",(0,r.jsx)(n.code,{children:"requestTypeDefinition"})," and ",(0,r.jsx)(n.code,{children:"responseTypeDefinition"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Timeouts:"})," Configure maximum wait times for responses (",(0,r.jsx)(n.code,{children:"timeout"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reliability:"})," Integrate with Circuit Breakers (",(0,r.jsx)(n.code,{children:"circuitBreaker"})," option) to handle failing endpoints gracefully."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compression:"})," Automatic compression for large request/response payloads."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"server-side-usage",children:"Server-Side Usage"}),"\n",(0,r.jsx)(n.h3,{id:"registering-a-request-event",children:"Registering a Request Event"}),"\n",(0,r.jsxs)(n.p,{children:["Define a request endpoint using ",(0,r.jsx)(n.code,{children:"NetRay:RegisterRequestEvent(eventName, options?)"})," on the server."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- Server Script\nlocal shopPurchaseRequest = NetRay:RegisterRequestEvent("PurchaseItem", {\n    requestTypeDefinition = {\n        itemId = "number",\n        quantity = "number"\n    },\n    responseTypeDefinition = {\n        success = "boolean",\n        message = "?string",       -- Optional message (e.g., error reason)\n        newBalance = "?number"    -- Optional updated currency balance\n    },\n    circuitBreaker = { failureThreshold = 5, resetTimeout = 30 }, -- Example\n    timeout = 8 -- Server timeout for server->client invoke (less common)\n    })\n'})}),"\n",(0,r.jsx)(n.h3,{id:"handling-client-requests",children:"Handling Client Requests"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:":OnRequest(callback)"})," to define the function that processes requests and returns data. The function's return value (or error) resolves/rejects the client's Promise."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- Server Script\nlocal PlayerData = require(game.ServerStorage.PlayerData) -- Your player data module\nlocal ShopItems = require(game.ServerStorage.ShopItems)   -- Your shop item definitions\n\nshopPurchaseRequest:OnRequest(function(player, data)\n-- \'player\' is the client making the request\n-- \'data\' is the validated request payload\n\nlocal itemId = data.itemId\n-- Validate quantity, default to 1 if invalid/missing from payload\nlocal quantity = (type(data.quantity) == "number" and data.quantity > 0) and math.floor(data.quantity) or 1\n\nlocal itemInfo = ShopItems:GetInfo(itemId)\nif not itemInfo then\n    error("Invalid item ID: " .. tostring(itemId)) -- Goes to client .catch()\nend\n\nlocal currentCoins = PlayerData:GetCoins(player.UserId)\nlocal totalCost = itemInfo.Price * quantity\n\nif currentCoins < totalCost then\n    -- Returning a table indicates success to the Promise, client must check \'success\' field\n    return { success = false, message = "Insufficient coins." }\nend\n\n-- Attempt purchase transaction\nlocal purchaseOk, failureReason = PlayerData:PurchaseItem(player.UserId, itemId, quantity, totalCost)\n\nif not purchaseOk then\n    -- Can return failure status or throw error\n    return { success = false, message = "Transaction failed: " .. (failureReason or "Unknown") }\n    -- Alternatively: error("Transaction failed: " .. (failureReason or "Unknown"))\nend\n\nlocal newBalance = PlayerData:GetCoins(player.UserId)\n\n-- Purchase successful, goes to client .andThen()\nreturn {\n    success = true,\n    message = "Purchased " .. quantity .. "x " .. itemInfo.Name,\n    newBalance = newBalance\n}\nend)\n'})}),"\n",(0,r.jsx)(n.h3,{id:"invoking-requests-on-clients-server---client",children:"Invoking Requests on Clients (Server -> Client)"}),"\n",(0,r.jsx)(n.p,{children:"Server can request information from a specific client."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- Server Script\nlocal getClientInputMode = NetRay:RegisterRequestEvent("GetClientInputMode", {\n    responseTypeDefinition = { inputMode = "string" } -- e.g., "KeyboardMouse", "Gamepad", "Touch"\n})\n\n-- In some server logic:\nlocal function checkInputMode(player)\n    print("Requesting input mode from", player.Name)\n    getClientInputMode:Request(player, {}) -- Send empty table if no data needed\n        :andThen(function(response)\n            print(("%s is using: %s"):format(player.Name, response.inputMode))\n            -- Use the info...\n        end)\n        :catch(function(err)\n            warn(("Failed to get input mode from %s: %s"):format(player.Name, err))\n            -- Handle failure, maybe assume default?\n        end)\nend\n'})}),"\n",(0,r.jsx)(n.h2,{id:"client-side-usage",children:"Client-Side Usage"}),"\n",(0,r.jsx)(n.h3,{id:"gettingregistering-a-request-event",children:"Getting/Registering a Request Event"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"NetRay:RegisterRequestEvent(eventName, options?)"})," on the client to get a reference for making requests ",(0,r.jsx)(n.em,{children:"to"})," the server or handling requests ",(0,r.jsx)(n.em,{children:"from"})," the server."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- Client Script\n-- Define reference and potentially client-side timeout for server response\nlocal purchaseItemRequest = NetRay:RegisterRequestEvent("PurchaseItem", {\n    timeout = 15 -- Wait max 15s for server to respond\n})\n'})}),"\n",(0,r.jsx)(n.h3,{id:"making-requests-to-server",children:"Making Requests to Server"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:":Request(data)"}),", which returns a ",(0,r.jsx)(n.code,{children:"Promise"}),". Chain ",(0,r.jsx)(n.code,{children:".andThen(successCallback)"})," and ",(0,r.jsx)(n.code,{children:".catch(errorCallback)"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- Client Script\nlocal ShopInterface = {} -- Your shop UI module\nShopInterface.SetLoadingState = function(self, isLoading) print("Shop loading state:", isLoading) end -- Placeholder\n\nfunction ShopInterface:TryPurchase(itemId, quantity)\n    print(("Attempting purchase: Item %d, Quantity %d"):format(itemId, quantity))\n        self:SetLoadingState(true) -- Update UI\n\n        purchaseItemRequest:Request({ itemId = itemId, quantity = quantity })\n            :andThen(function(response)\n                -- Server\'s response (\'return\' value from :OnRequest)\n                if response.success then\n                    print("Purchase successful!", response.message)\n                    -- Update coin display: ShopInterface:UpdateCoinDisplay(response.newBalance)\n                else\n                    warn("Purchase failed:", response.message or "No reason given.")\n                    -- Show failure message in UI\n                end\n            end)\n            :catch(function(errorMessage)\n                -- Catches errors from the server (error() call in handler),\n                -- network timeouts, circuit breaker blocks, etc.\n                warn("Error during purchase request:", errorMessage)\n                -- Show a generic error message in UI\n            end)\n            :finally(function()\n                -- Runs whether the request succeeded or failed\n                print("Purchase request finished.")\n                self:SetLoadingState(false) -- Update UI\n            end)\nend\n'})}),"\n",(0,r.jsx)(n.h3,{id:"example-usage-eg-connected-to-a-buy-button",children:"Example Usage (e.g., connected to a Buy button)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"ShopInterface:TryPurchase(101, 1)\nShopInterface:TryPurchase(102, 5)\nShopInterface:TryPurchase(999, 1) -- Example invalid item\n"})}),"\n",(0,r.jsx)(n.h3,{id:"handling-server-requests-client---server-response",children:"Handling Server Requests (Client -> Server Response)"}),"\n",(0,r.jsxs)(n.p,{children:["Define a handler using ",(0,r.jsx)(n.code,{children:":OnRequest(callback)"})," for requests initiated ",(0,r.jsx)(n.em,{children:"by"})," the server."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- Client Script\nlocal UserInputService = game:GetService("UserInputService")\nlocal getClientInputMode = NetRay:RegisterRequestEvent("GetClientInputMode")\n\ngetClientInputMode:OnRequest(function(dataFromServer)\n    print("Server requested client input mode. Data received:", dataFromServer)\n\n    local inputMode = "KeyboardMouse" -- Default\n    if UserInputService.TouchEnabled and not UserInputService.MouseEnabled then\n        inputMode = "Touch"\n    elseif UserInputService.GamepadEnabled then\n        local connectedGamepads = UserInputService:GetConnectedGamepads()\n        if #connectedGamepads > 0 then\n            inputMode = "Gamepad"\n        end\n    end\n\n    -- Return value is sent back to the server\'s .andThen()\n    return {\n        inputMode = inputMode\n    }\nend)\n'})}),"\n",(0,r.jsx)(n.h3,{id:"example-request-registration",children:"Example Request Registration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- Example of request registration\nlocal purchaseRequest = NetRay:RegisterRequestEvent("PurchaseItem", {\n    requestTypeDefinition = {\n        itemId = "number",\n        quantity = "number"\n    },\n    responseTypeDefinition = {\n        success = "boolean",\n        message = "string",\n        newItemId = "?number" -- Optional return value\n    }\n})\n\n-- Server-side handler\npurchaseRequest.OnServerInvoke = function(player, requestData)\n    -- Validate request\n    if requestData.quantity <= 0 then\n        return { success = false, message = "Quantity must be positive" }\n    end\n\n    -- Process purchase\n    local success, itemId = processPurchase(player, requestData.itemId, requestData.quantity)\n    return {\n        success = success,\n        message = success and "Purchase successful" or "Purchase failed",\n        newItemId = itemId\n    }\nend\n'})})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(6540);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);