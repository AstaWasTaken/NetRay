"use strict";(self.webpackChunknet_ray_docs=self.webpackChunknet_ray_docs||[]).push([[897],{3581:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>g,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"core-concepts/events","title":"Events (Fire-and-Forget)","description":"Events in NetRay are unidirectional, \\"fire-and-forget\\" messages, analogous to Roblox\'s RemoteEvent. Use them to broadcast information or trigger actions where an immediate response isn\'t required.","source":"@site/docs/core-concepts/events.md","sourceDirName":"core-concepts","slug":"/core-concepts/events","permalink":"/NetRay/docs/core-concepts/events","draft":false,"unlisted":false,"editUrl":"https://github.com/AstaWasTaken/NetRay/docs/core-concepts/events.md","tags":[],"version":"current","frontMatter":{"title":"Events (Fire-and-Forget)"},"sidebar":"docsSidebar","previous":{"title":"Core Concepts","permalink":"/NetRay/docs/category/core-concepts"},"next":{"title":"Requests (Request/Response)","permalink":"/NetRay/docs/core-concepts/requests"}}');var a=t(4848),i=t(8453);const s={title:"Events (Fire-and-Forget)"},l="Core Concepts: Events",o={},c=[{value:"Key Features",id:"key-features",level:2},{value:"Server-Side Usage",id:"server-side-usage",level:2},{value:"Registering an Event",id:"registering-an-event",level:3},{value:"Listening for Client Events",id:"listening-for-client-events",level:3},{value:"Firing Events to Clients",id:"firing-events-to-clients",level:3},{value:"Client-Side Usage",id:"client-side-usage",level:2},{value:"Getting an Event Reference",id:"getting-an-event-reference",level:3},{value:"Listening for Server Events",id:"listening-for-server-events",level:3},{value:"Firing Events to Server",id:"firing-events-to-server",level:3},{value:"Example Usage",id:"example-usage",level:3}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"core-concepts-events",children:"Core Concepts: Events"})}),"\n",(0,a.jsxs)(n.p,{children:['Events in NetRay are unidirectional, "fire-and-forget" messages, analogous to Roblox\'s ',(0,a.jsx)(n.code,{children:"RemoteEvent"}),". Use them to broadcast information or trigger actions where an immediate response isn't required."]}),"\n",(0,a.jsx)(n.h2,{id:"key-features",children:"Key Features"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Type Safety:"})," Optionally define data structures (",(0,a.jsx)(n.code,{children:"typeDefinition"}),") for automatic validation upon receiving."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Prioritization:"})," Control client-side processing order using ",(0,a.jsx)(n.code,{children:"priority"})," levels."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Batching:"})," Server-to-client events are automatically grouped (",(0,a.jsx)(n.code,{children:"batchable = true"}),") to reduce network calls."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Compression:"})," Large payloads may be automatically compressed (",(0,a.jsx)(n.code,{children:"compression = true"}),") by the ",(0,a.jsx)(n.code,{children:"DynamicSender"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"server-side-usage",children:"Server-Side Usage"}),"\n",(0,a.jsx)(n.h3,{id:"registering-an-event",children:"Registering an Event"}),"\n",(0,a.jsxs)(n.p,{children:["Use ",(0,a.jsx)(n.code,{children:"NetRay:RegisterEvent(eventName, options?)"})," on the server."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Server Script\r\nlocal damageDealtEvent = NetRay:RegisterEvent("DamageDealt", {\r\n    -- Recommended: Define the data structure for clarity and validation\r\n    typeDefinition = {\r\n        targetInstanceId = "number", -- Use a reliable way to identify instances (e.g., custom attribute ID)\r\n        damageAmount = "number",\r\n        damageType = "?string",       -- Optional: e.g., "Fire", "Physical"\r\n        critMultiplier = "number|nil" -- Optional, number or nil\r\n    },\r\n    priority = NetRay.Priority.HIGH, -- Ensure damage events are handled quickly client-side\r\n    batchable = true                 -- Efficient for frequent damage updates\r\n})\n'})}),"\n",(0,a.jsx)(n.h3,{id:"listening-for-client-events",children:"Listening for Client Events"}),"\n",(0,a.jsxs)(n.p,{children:["Handle events sent ",(0,a.jsx)(n.em,{children:"from"})," clients using ",(0,a.jsx)(n.code,{children:":OnEvent(callback)"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Server Script\r\ndamageDealtEvent:OnEvent(function(player, data)\r\n    -- \'player\' is the Player who fired the event\r\n    -- \'data\' is the validated payload (if typeDefinition was provided)\r\n\r\n    -- You\'ll need a reliable way to map targetInstanceId back to an Instance\r\n    -- This is game-specific logic. FindFirstChild is unreliable for dynamic objects.\r\n    -- local target = YourGameSpecificInstanceManager:GetInstanceById(data.targetInstanceId)\r\n    local target = game.Workspace:FindFirstChild("Target_" .. data.targetInstanceId) -- Placeholder lookup\r\n\r\n    if target and target:FindFirstChildOfClass("Humanoid") then\r\n        local humanoid = target:FindFirstChildOfClass("Humanoid")\r\n        local actualDamage = data.damageAmount * (data.critMultiplier or 1)\r\n\r\n        print(("%s dealt %.1f %s damage to %s."):format(\r\n            player.Name,\r\n            actualDamage,\r\n            data.damageType or "Unknown",\r\n            target.Name\r\n        ))\r\n        humanoid:TakeDamage(actualDamage)\r\n    else\r\n        warn("Invalid target or missing Humanoid for damage event from", player.Name, "TargetID:", data.targetInstanceId)\r\n    end\r\nend)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"firing-events-to-clients",children:"Firing Events to Clients"}),"\n",(0,a.jsxs)(n.p,{children:["Send events ",(0,a.jsx)(n.em,{children:"to"})," clients using the ",(0,a.jsx)(n.code,{children:":Fire...()"})," methods."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Server Script\r\n-- Assuming player references (attackerPlayer, targetPlayer, immunePlayer) exist\r\nif attackerPlayer then\r\n    -- Send to a specific player who landed a critical hit\r\n    damageDealtEvent:FireClient(attackerPlayer, {\r\n        targetInstanceId = 0, -- Use a special ID for UI feedback maybe\r\n        damageAmount = 150,\r\n        damageType = "CritFeedback",\r\n        critMultiplier = 2.5\r\n    })\r\nend\r\n\r\n-- Broadcast an area effect damage event\r\ndamageDealtEvent:FireAllClients({\r\n    targetInstanceId = -1, -- Use special ID for AoE\r\n    damageAmount = 30,\r\n    damageType = "Explosion"\r\n    -- Might also include position = Vector3...\r\n})\r\n\r\n-- Notify everyone except the target about a status effect\r\nif targetPlayer then\r\n    -- Assuming StatusEffectApplied event is registered elsewhere\r\n    local statusEffectEvent = NetRay:RegisterEvent("StatusEffectApplied") -- Register ensures it exists\r\n    statusEffectEvent:FireAllClientsExcept(targetPlayer, {\r\n        targetName = targetPlayer.Name,\r\n        effect = "Slowed",\r\n        duration = 5\r\n    })\r\nend\r\n\r\n-- Send event only to players on Team A\r\nlocal teamUpdateEvent = NetRay:RegisterEvent("TeamUpdate")\r\n    teamUpdateEvent:FireFilteredClients(function(p)\r\n        -- Make sure player.Team and player.Team.Name exist and are valid\r\n        return p.Team and p.Team.Name == "Team A"\r\n    end, {\r\n        message = "Objective captured!",\r\n        points = 100\r\n    })\r\nend\n'})}),"\n",(0,a.jsx)(n.h2,{id:"client-side-usage",children:"Client-Side Usage"}),"\n",(0,a.jsx)(n.h3,{id:"getting-an-event-reference",children:"Getting an Event Reference"}),"\n",(0,a.jsxs)(n.p,{children:["Use ",(0,a.jsx)(n.code,{children:"NetRay:GetEvent(eventName)"})," to access an event. Use ",(0,a.jsx)(n.code,{children:"NetRay:RegisterEvent(eventName, options?)"})," if you need to set client-specific options ",(0,a.jsx)(n.em,{children:"before"})," the first event is potentially received or fired (less common)."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Client Script\r\n-- Get a reference (most common)\r\nlocal damageDealtEvent = NetRay:GetEvent("DamageDealt")\r\n\r\n-- Or register if you need specific client options (like listener priority)\r\n-- local damageDealtEvent = NetRay:RegisterEvent("DamageDealt", { priority = NetRay.Priority.CRITICAL })\n'})}),"\n",(0,a.jsx)(n.h3,{id:"listening-for-server-events",children:"Listening for Server Events"}),"\n",(0,a.jsxs)(n.p,{children:["Handle events sent ",(0,a.jsx)(n.em,{children:"from"})," the server using ",(0,a.jsx)(n.code,{children:":OnEvent(callback)"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Client Script\r\nlocal LocalPlayer = game:GetService("Players").LocalPlayer\r\n-- Assume some way to get the local player\'s character unique ID if needed\r\n-- local localCharacterId = LocalPlayer.Character and LocalPlayer.Character:GetAttribute("InstanceId")\r\n\r\ndamageDealtEvent:OnEvent(function(data)\r\n    -- \'data\' is the validated payload from the server\r\n\r\n    local localCharacterId = LocalPlayer.Character and LocalPlayer.Character:GetAttribute("InstanceId")\r\n\r\n    -- Show damage numbers or effects\r\n    if data.damageType == "CritFeedback" then\r\n        print("CRITICAL HIT UI FEEDBACK!")\r\n        -- TriggerCritUI()\r\n        elseif data.targetInstanceId == localCharacterId then -- Check if this client was the target\r\n            print(("Took %.1f %s damage!"):format(data.damageAmount, data.damageType or "Unknown"))\r\n            -- UpdateHealthBarUI(data.damageAmount)\r\n            -- ShowDamageVignette()\r\n        elseif data.targetInstanceId == -1 and data.damageType == "Explosion" then\r\n            -- Play explosion sound/visual near event source (if position was included in \'data\')\r\n            print("Nearby explosion!")\r\n            -- PlayExplosionEffect(data.position)\r\n    end\r\nend)\r\n\r\n-- Also listen for the status effect event\r\nlocal statusEffectEvent = NetRay:GetEvent("StatusEffectApplied")\r\nstatusEffectEvent:OnEvent(function(data)\r\n    if data.targetName == LocalPlayer.Name then\r\n        print(("You were afflicted with %s for %d seconds!"):format(data.effect, data.duration))\r\n        -- Apply visual effect on local player?\r\n    elseif data.targetName == LocalPlayer.Name then\r\n        print(("%s was afflicted with %s."):format(data.targetName, data.effect))\r\n        -- Show indicator on other player\'s nameplate?\r\n    end\r\nend)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"firing-events-to-server",children:"Firing Events to Server"}),"\n",(0,a.jsxs)(n.p,{children:["Send events ",(0,a.jsx)(n.em,{children:"to"})," the server using ",(0,a.jsx)(n.code,{children:":FireServer(data)"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Client Script\r\nlocal userInputService = game:GetService("UserInputService")\r\nlocal requestDamageEvent = NetRay:GetEvent("DamageDealt") -- Event server listens to for damage reports\r\n\r\nlocal function getTargetInstanceId(target)\r\n    -- Implement your logic to get a *server-known* ID for the target instance\r\n    -- Using attributes is a common method\r\n    return target and target:GetAttribute("InstanceId")\r\nend\r\n\r\nuserInputService.InputBegan:Connect(function(input, gameProcessed)\r\n    if gameProcessed then return end\r\n    if input.UserInputType == Enum.UserInputType.MouseButton1 then -- Left click\r\n        local player = game:GetService("Players").LocalPlayer\r\n        local mouse = player:GetMouse()\r\n        local targetInstance = mouse.Target\r\n        local targetId = getTargetInstanceId(targetInstance) -- Use helper function\r\n\r\n        if targetId then\r\n            print("Attempting to trigger damage event for target ID:", targetId)\r\n            -- Client tells server it *hit* something. Server validates/calculates damage.\r\n            requestDamageEvent:FireServer({\r\n                targetInstanceId = targetId,\r\n                damageAmount = 10, -- Client might suggest base damage or weapon type\r\n                damageType = "MeleeSwing"\r\n            })\r\n        end\r\n    end)\r\nend)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"example-usage",children:"Example Usage"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'-- Example of event registration\r\nlocal damageDealtEvent = NetRay:RegisterEvent("DamageDealt", {\r\n    -- Recommended: Define the data structure for clarity and validation\r\n    typeDefinition = {\r\n        targetInstanceId = "number", -- Use a reliable way to identify instances (e.g., custom attribute ID)\r\n        damageAmount = "number",\r\n        damageType = "string",\r\n        position = "Vector3"\r\n    }\r\n})\r\n\r\n-- Example of firing the event\r\nlocal target = game.Workspace:FindFirstChild("Target")\r\ndamageDealtEvent:FireAllClients({\r\n    targetInstanceId = target:GetAttribute("ID"),\r\n    damageAmount = 10,\r\n    damageType = "Physical",\r\n    position = target.Position\r\n})\n'})})]})}function g(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var r=t(6540);const a={},i=r.createContext(a);function s(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);