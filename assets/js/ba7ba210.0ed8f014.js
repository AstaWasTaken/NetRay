"use strict";(self.webpackChunknet_ray_docs=self.webpackChunknet_ray_docs||[]).push([[293],{888:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"core-concepts/requests","title":"Requests (Request/Response)","description":"Requests in NetRay handle two-way communication where a response is expected, replacing the need for RemoteFunction. They utilize Promises for cleaner asynchronous code flow.","source":"@site/docs/core-concepts/requests.md","sourceDirName":"core-concepts","slug":"/core-concepts/requests","permalink":"/NetRay/docs/core-concepts/requests","draft":false,"unlisted":false,"editUrl":"https://github.com/AstaWasTaken/NetRay/docs/core-concepts/requests.md","tags":[],"version":"current","frontMatter":{"title":"Requests (Request/Response)"},"sidebar":"docsSidebar","previous":{"title":"Events (Fire-and-Forget)","permalink":"/NetRay/docs/core-concepts/events"},"next":{"title":"Advanced Features","permalink":"/NetRay/docs/category/advanced-features"}}');var s=r(4848),a=r(8453);const i={title:"Requests (Request/Response)"},o="Core Concepts: Requests",c={},l=[{value:"Key Features",id:"key-features",level:2},{value:"Server-Side Usage",id:"server-side-usage",level:2},{value:"Registering a Request Event",id:"registering-a-request-event",level:3},{value:"Handling Client Requests",id:"handling-client-requests",level:3},{value:"Invoking Requests on Clients (Server -&gt; Client)",id:"invoking-requests-on-clients-server---client",level:3},{value:"Client-Side Usage",id:"client-side-usage",level:2},{value:"Getting/Registering a Request Event",id:"gettingregistering-a-request-event",level:3},{value:"Making Requests to Server",id:"making-requests-to-server",level:3},{value:"Example Usage (e.g., connected to a Buy button)",id:"example-usage-eg-connected-to-a-buy-button",level:3},{value:"Handling Server Requests (Client -&gt; Server Response)",id:"handling-server-requests-client---server-response",level:3},{value:"Example Request Registration",id:"example-request-registration",level:3}];function u(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"core-concepts-requests",children:"Core Concepts: Requests"})}),"\n",(0,s.jsxs)(n.p,{children:["Requests in NetRay handle two-way communication where a response is expected, replacing the need for ",(0,s.jsx)(n.code,{children:"RemoteFunction"}),". They utilize Promises for cleaner asynchronous code flow."]}),"\n",(0,s.jsx)(n.h2,{id:"key-features",children:"Key Features"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Asynchronous:"})," Uses a ",(0,s.jsx)(n.code,{children:"Promise"})," API (",(0,s.jsx)(n.code,{children:".andThen()"}),", ",(0,s.jsx)(n.code,{children:".catch()"}),", ",(0,s.jsx)(n.code,{children:".finally()"}),") avoiding yields."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type Safety:"})," Define expected structures for ",(0,s.jsx)(n.em,{children:"both"})," the request and response using ",(0,s.jsx)(n.code,{children:"requestTypeDefinition"})," and ",(0,s.jsx)(n.code,{children:"responseTypeDefinition"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Timeouts:"})," Configure maximum wait times for responses (",(0,s.jsx)(n.code,{children:"timeout"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reliability:"})," Integrate with Circuit Breakers (",(0,s.jsx)(n.code,{children:"circuitBreaker"})," option) to handle failing endpoints gracefully."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Compression:"})," Automatic compression for large request/response payloads."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"server-side-usage",children:"Server-Side Usage"}),"\n",(0,s.jsx)(n.h3,{id:"registering-a-request-event",children:"Registering a Request Event"}),"\n",(0,s.jsxs)(n.p,{children:["Define a request endpoint using ",(0,s.jsx)(n.code,{children:"NetRay:RegisterRequestEvent(eventName, options?)"})," on the server."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Server Script\r\nlocal shopPurchaseRequest = NetRay:RegisterRequestEvent("PurchaseItem", {\r\n    requestTypeDefinition = {\r\n        itemId = "number",\r\n        quantity = "number"\r\n    },\r\n    responseTypeDefinition = {\r\n        success = "boolean",\r\n        message = "?string",       -- Optional message (e.g., error reason)\r\n        newBalance = "?number"    -- Optional updated currency balance\r\n    },\r\n    circuitBreaker = { failureThreshold = 5, resetTimeout = 30 }, -- Example\r\n    timeout = 8 -- Server timeout for server->client invoke (less common)\r\n    })\n'})}),"\n",(0,s.jsx)(n.h3,{id:"handling-client-requests",children:"Handling Client Requests"}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:":OnRequest(callback)"})," to define the function that processes requests and returns data. The function's return value (or error) resolves/rejects the client's Promise."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Server Script\r\nlocal PlayerData = require(game.ServerStorage.PlayerData) -- Your player data module\r\nlocal ShopItems = require(game.ServerStorage.ShopItems)   -- Your shop item definitions\r\n\r\nshopPurchaseRequest:OnRequest(function(player, data)\r\n-- \'player\' is the client making the request\r\n-- \'data\' is the validated request payload\r\n\r\nlocal itemId = data.itemId\r\n-- Validate quantity, default to 1 if invalid/missing from payload\r\nlocal quantity = (type(data.quantity) == "number" and data.quantity > 0) and math.floor(data.quantity) or 1\r\n\r\nlocal itemInfo = ShopItems:GetInfo(itemId)\r\nif not itemInfo then\r\n    error("Invalid item ID: " .. tostring(itemId)) -- Goes to client .catch()\r\nend\r\n\r\nlocal currentCoins = PlayerData:GetCoins(player.UserId)\r\nlocal totalCost = itemInfo.Price * quantity\r\n\r\nif currentCoins < totalCost then\r\n    -- Returning a table indicates success to the Promise, client must check \'success\' field\r\n    return { success = false, message = "Insufficient coins." }\r\nend\r\n\r\n-- Attempt purchase transaction\r\nlocal purchaseOk, failureReason = PlayerData:PurchaseItem(player.UserId, itemId, quantity, totalCost)\r\n\r\nif not purchaseOk then\r\n    -- Can return failure status or throw error\r\n    return { success = false, message = "Transaction failed: " .. (failureReason or "Unknown") }\r\n    -- Alternatively: error("Transaction failed: " .. (failureReason or "Unknown"))\r\nend\r\n\r\nlocal newBalance = PlayerData:GetCoins(player.UserId)\r\n\r\n-- Purchase successful, goes to client .andThen()\r\nreturn {\r\n    success = true,\r\n    message = "Purchased " .. quantity .. "x " .. itemInfo.Name,\r\n    newBalance = newBalance\r\n}\r\nend)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"invoking-requests-on-clients-server---client",children:"Invoking Requests on Clients (Server -> Client)"}),"\n",(0,s.jsx)(n.p,{children:"Server can request information from a specific client."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Server Script\r\nlocal getClientInputMode = NetRay:RegisterRequestEvent("GetClientInputMode", {\r\n    responseTypeDefinition = { inputMode = "string" } -- e.g., "KeyboardMouse", "Gamepad", "Touch"\r\n})\r\n\r\n-- In some server logic:\r\nlocal function checkInputMode(player)\r\n    print("Requesting input mode from", player.Name)\r\n    getClientInputMode:Request(player, {}) -- Send empty table if no data needed\r\n        :andThen(function(response)\r\n            print(("%s is using: %s"):format(player.Name, response.inputMode))\r\n            -- Use the info...\r\n        end)\r\n        :catch(function(err)\r\n            warn(("Failed to get input mode from %s: %s"):format(player.Name, err))\r\n            -- Handle failure, maybe assume default?\r\n        end)\r\nend\n'})}),"\n",(0,s.jsx)(n.h2,{id:"client-side-usage",children:"Client-Side Usage"}),"\n",(0,s.jsx)(n.h3,{id:"gettingregistering-a-request-event",children:"Getting/Registering a Request Event"}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"NetRay:RegisterRequestEvent(eventName, options?)"})," on the client to get a reference for making requests ",(0,s.jsx)(n.em,{children:"to"})," the server or handling requests ",(0,s.jsx)(n.em,{children:"from"})," the server."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Client Script\r\n-- Define reference and potentially client-side timeout for server response\r\nlocal purchaseItemRequest = NetRay:RegisterRequestEvent("PurchaseItem", {\r\n    timeout = 15 -- Wait max 15s for server to respond\r\n})\n'})}),"\n",(0,s.jsx)(n.h3,{id:"making-requests-to-server",children:"Making Requests to Server"}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:":Request(data)"}),", which returns a ",(0,s.jsx)(n.code,{children:"Promise"}),". Chain ",(0,s.jsx)(n.code,{children:".andThen(successCallback)"})," and ",(0,s.jsx)(n.code,{children:".catch(errorCallback)"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Client Script\r\nlocal ShopInterface = {} -- Your shop UI module\r\nShopInterface.SetLoadingState = function(self, isLoading) print("Shop loading state:", isLoading) end -- Placeholder\r\n\r\nfunction ShopInterface:TryPurchase(itemId, quantity)\r\n    print(("Attempting purchase: Item %d, Quantity %d"):format(itemId, quantity))\r\n        self:SetLoadingState(true) -- Update UI\r\n\r\n        purchaseItemRequest:Request({ itemId = itemId, quantity = quantity })\r\n            :andThen(function(response)\r\n                -- Server\'s response (\'return\' value from :OnRequest)\r\n                if response.success then\r\n                    print("Purchase successful!", response.message)\r\n                    -- Update coin display: ShopInterface:UpdateCoinDisplay(response.newBalance)\r\n                else\r\n                    warn("Purchase failed:", response.message or "No reason given.")\r\n                    -- Show failure message in UI\r\n                end\r\n            end)\r\n            :catch(function(errorMessage)\r\n                -- Catches errors from the server (error() call in handler),\r\n                -- network timeouts, circuit breaker blocks, etc.\r\n                warn("Error during purchase request:", errorMessage)\r\n                -- Show a generic error message in UI\r\n            end)\r\n            :finally(function()\r\n                -- Runs whether the request succeeded or failed\r\n                print("Purchase request finished.")\r\n                self:SetLoadingState(false) -- Update UI\r\n            end)\r\nend\n'})}),"\n",(0,s.jsx)(n.h3,{id:"example-usage-eg-connected-to-a-buy-button",children:"Example Usage (e.g., connected to a Buy button)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"ShopInterface:TryPurchase(101, 1)\r\nShopInterface:TryPurchase(102, 5)\r\nShopInterface:TryPurchase(999, 1) -- Example invalid item\n"})}),"\n",(0,s.jsx)(n.h3,{id:"handling-server-requests-client---server-response",children:"Handling Server Requests (Client -> Server Response)"}),"\n",(0,s.jsxs)(n.p,{children:["Define a handler using ",(0,s.jsx)(n.code,{children:":OnRequest(callback)"})," for requests initiated ",(0,s.jsx)(n.em,{children:"by"})," the server."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Client Script\r\nlocal UserInputService = game:GetService("UserInputService")\r\nlocal getClientInputMode = NetRay:RegisterRequestEvent("GetClientInputMode")\r\n\r\ngetClientInputMode:OnRequest(function(dataFromServer)\r\n    print("Server requested client input mode. Data received:", dataFromServer)\r\n\r\n    local inputMode = "KeyboardMouse" -- Default\r\n    if UserInputService.TouchEnabled and not UserInputService.MouseEnabled then\r\n        inputMode = "Touch"\r\n    elseif UserInputService.GamepadEnabled then\r\n        local connectedGamepads = UserInputService:GetConnectedGamepads()\r\n        if #connectedGamepads > 0 then\r\n            inputMode = "Gamepad"\r\n        end\r\n    end\r\n\r\n    -- Return value is sent back to the server\'s .andThen()\r\n    return {\r\n        inputMode = inputMode\r\n    }\r\nend)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"example-request-registration",children:"Example Request Registration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Example of request registration\r\nlocal purchaseRequest = NetRay:RegisterRequestEvent("PurchaseItem", {\r\n    requestTypeDefinition = {\r\n        itemId = "number",\r\n        quantity = "number"\r\n    },\r\n    responseTypeDefinition = {\r\n        success = "boolean",\r\n        message = "string",\r\n        newItemId = "?number" -- Optional return value\r\n    }\r\n})\r\n\r\n-- Server-side handler\r\npurchaseRequest.OnServerInvoke = function(player, requestData)\r\n    -- Validate request\r\n    if requestData.quantity <= 0 then\r\n        return { success = false, message = "Quantity must be positive" }\r\n    end\r\n\r\n    -- Process purchase\r\n    local success, itemId = processPurchase(player, requestData.itemId, requestData.quantity)\r\n    return {\r\n        success = success,\r\n        message = success and "Purchase successful" or "Purchase failed",\r\n        newItemId = itemId\r\n    }\r\nend\n'})})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var t=r(6540);const s={},a=t.createContext(s);function i(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);