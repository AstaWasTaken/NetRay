"use strict";(self.webpackChunknet_ray_docs=self.webpackChunknet_ray_docs||[]).push([[897],{3581:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>g,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"core-concepts/events","title":"Events (Fire-and-Forget)","description":"Events in NetRay are unidirectional, \\"fire-and-forget\\" messages, analogous to Roblox\'s RemoteEvent. Use them to broadcast information or trigger actions where an immediate response isn\'t required.","source":"@site/docs/core-concepts/events.md","sourceDirName":"core-concepts","slug":"/core-concepts/events","permalink":"/NetRay/docs/core-concepts/events","draft":false,"unlisted":false,"editUrl":"https://github.com/AstaWasTaken/NetRay/docs/core-concepts/events.md","tags":[],"version":"current","frontMatter":{"title":"Events (Fire-and-Forget)"},"sidebar":"docsSidebar","previous":{"title":"Core Concepts","permalink":"/NetRay/docs/category/core-concepts"},"next":{"title":"Requests (Request/Response)","permalink":"/NetRay/docs/core-concepts/requests"}}');var r=t(4848),i=t(8453);const s={title:"Events (Fire-and-Forget)"},l="Core Concepts: Events",o={},c=[{value:"Key Features",id:"key-features",level:2},{value:"Server-Side Usage",id:"server-side-usage",level:2},{value:"Registering an Event",id:"registering-an-event",level:3},{value:"Listening for Client Events",id:"listening-for-client-events",level:3},{value:"Firing Events to Clients",id:"firing-events-to-clients",level:3},{value:"Client-Side Usage",id:"client-side-usage",level:2},{value:"Getting an Event Reference",id:"getting-an-event-reference",level:3},{value:"Listening for Server Events",id:"listening-for-server-events",level:3},{value:"Firing Events to Server",id:"firing-events-to-server",level:3},{value:"Example Usage",id:"example-usage",level:3}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"core-concepts-events",children:"Core Concepts: Events"})}),"\n",(0,r.jsxs)(n.p,{children:['Events in NetRay are unidirectional, "fire-and-forget" messages, analogous to Roblox\'s ',(0,r.jsx)(n.code,{children:"RemoteEvent"}),". Use them to broadcast information or trigger actions where an immediate response isn't required."]}),"\n",(0,r.jsx)(n.h2,{id:"key-features",children:"Key Features"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type Safety:"})," Optionally define data structures (",(0,r.jsx)(n.code,{children:"typeDefinition"}),") for automatic validation upon receiving."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Prioritization:"})," Control client-side processing order using ",(0,r.jsx)(n.code,{children:"priority"})," levels."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Batching:"})," Server-to-client events are automatically grouped (",(0,r.jsx)(n.code,{children:"batchable = true"}),") to reduce network calls."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compression:"})," Large payloads may be automatically compressed (",(0,r.jsx)(n.code,{children:"compression = true"}),") by the ",(0,r.jsx)(n.code,{children:"DynamicSender"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"server-side-usage",children:"Server-Side Usage"}),"\n",(0,r.jsx)(n.h3,{id:"registering-an-event",children:"Registering an Event"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"NetRay:RegisterEvent(eventName, options?)"})," on the server."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- Server Script\nlocal damageDealtEvent = NetRay:RegisterEvent("DamageDealt", {\n    -- Recommended: Define the data structure for clarity and validation\n    typeDefinition = {\n        targetInstanceId = "number", -- Use a reliable way to identify instances (e.g., custom attribute ID)\n        damageAmount = "number",\n        damageType = "?string",       -- Optional: e.g., "Fire", "Physical"\n        critMultiplier = "number|nil" -- Optional, number or nil\n    },\n    priority = NetRay.Priority.HIGH, -- Ensure damage events are handled quickly client-side\n    batchable = true                 -- Efficient for frequent damage updates\n})\n'})}),"\n",(0,r.jsx)(n.h3,{id:"listening-for-client-events",children:"Listening for Client Events"}),"\n",(0,r.jsxs)(n.p,{children:["Handle events sent ",(0,r.jsx)(n.em,{children:"from"})," clients using ",(0,r.jsx)(n.code,{children:":OnEvent(callback)"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- Server Script\ndamageDealtEvent:OnEvent(function(player, data)\n    -- \'player\' is the Player who fired the event\n    -- \'data\' is the validated payload (if typeDefinition was provided)\n\n    -- You\'ll need a reliable way to map targetInstanceId back to an Instance\n    -- This is game-specific logic. FindFirstChild is unreliable for dynamic objects.\n    -- local target = YourGameSpecificInstanceManager:GetInstanceById(data.targetInstanceId)\n    local target = game.Workspace:FindFirstChild("Target_" .. data.targetInstanceId) -- Placeholder lookup\n\n    if target and target:FindFirstChildOfClass("Humanoid") then\n        local humanoid = target:FindFirstChildOfClass("Humanoid")\n        local actualDamage = data.damageAmount * (data.critMultiplier or 1)\n\n        print(("%s dealt %.1f %s damage to %s."):format(\n            player.Name,\n            actualDamage,\n            data.damageType or "Unknown",\n            target.Name\n        ))\n        humanoid:TakeDamage(actualDamage)\n    else\n        warn("Invalid target or missing Humanoid for damage event from", player.Name, "TargetID:", data.targetInstanceId)\n    end\nend)\n'})}),"\n",(0,r.jsx)(n.h3,{id:"firing-events-to-clients",children:"Firing Events to Clients"}),"\n",(0,r.jsxs)(n.p,{children:["Send events ",(0,r.jsx)(n.em,{children:"to"})," clients using the ",(0,r.jsx)(n.code,{children:":Fire...()"})," methods."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- Server Script\n-- Assuming player references (attackerPlayer, targetPlayer, immunePlayer) exist\nif attackerPlayer then\n    -- Send to a specific player who landed a critical hit\n    damageDealtEvent:FireClient(attackerPlayer, {\n        targetInstanceId = 0, -- Use a special ID for UI feedback maybe\n        damageAmount = 150,\n        damageType = "CritFeedback",\n        critMultiplier = 2.5\n    })\nend\n\n-- Broadcast an area effect damage event\ndamageDealtEvent:FireAllClients({\n    targetInstanceId = -1, -- Use special ID for AoE\n    damageAmount = 30,\n    damageType = "Explosion"\n    -- Might also include position = Vector3...\n})\n\n-- Notify everyone except the target about a status effect\nif targetPlayer then\n    -- Assuming StatusEffectApplied event is registered elsewhere\n    local statusEffectEvent = NetRay:RegisterEvent("StatusEffectApplied") -- Register ensures it exists\n    statusEffectEvent:FireAllClientsExcept(targetPlayer, {\n        targetName = targetPlayer.Name,\n        effect = "Slowed",\n        duration = 5\n    })\nend\n\n-- Send event only to players on Team A\nlocal teamUpdateEvent = NetRay:RegisterEvent("TeamUpdate")\n    teamUpdateEvent:FireFilteredClients(function(p)\n        -- Make sure player.Team and player.Team.Name exist and are valid\n        return p.Team and p.Team.Name == "Team A"\n    end, {\n        message = "Objective captured!",\n        points = 100\n    })\nend\n'})}),"\n",(0,r.jsx)(n.h2,{id:"client-side-usage",children:"Client-Side Usage"}),"\n",(0,r.jsx)(n.h3,{id:"getting-an-event-reference",children:"Getting an Event Reference"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"NetRay:GetEvent(eventName)"})," to access an event. Use ",(0,r.jsx)(n.code,{children:"NetRay:RegisterEvent(eventName, options?)"})," if you need to set client-specific options ",(0,r.jsx)(n.em,{children:"before"})," the first event is potentially received or fired (less common)."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- Client Script\n-- Get a reference (most common)\nlocal damageDealtEvent = NetRay:GetEvent("DamageDealt")\n\n-- Or register if you need specific client options (like listener priority)\n-- local damageDealtEvent = NetRay:RegisterEvent("DamageDealt", { priority = NetRay.Priority.CRITICAL })\n'})}),"\n",(0,r.jsx)(n.h3,{id:"listening-for-server-events",children:"Listening for Server Events"}),"\n",(0,r.jsxs)(n.p,{children:["Handle events sent ",(0,r.jsx)(n.em,{children:"from"})," the server using ",(0,r.jsx)(n.code,{children:":OnEvent(callback)"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- Client Script\nlocal LocalPlayer = game:GetService("Players").LocalPlayer\n-- Assume some way to get the local player\'s character unique ID if needed\n-- local localCharacterId = LocalPlayer.Character and LocalPlayer.Character:GetAttribute("InstanceId")\n\ndamageDealtEvent:OnEvent(function(data)\n    -- \'data\' is the validated payload from the server\n\n    local localCharacterId = LocalPlayer.Character and LocalPlayer.Character:GetAttribute("InstanceId")\n\n    -- Show damage numbers or effects\n    if data.damageType == "CritFeedback" then\n        print("CRITICAL HIT UI FEEDBACK!")\n        -- TriggerCritUI()\n        elseif data.targetInstanceId == localCharacterId then -- Check if this client was the target\n            print(("Took %.1f %s damage!"):format(data.damageAmount, data.damageType or "Unknown"))\n            -- UpdateHealthBarUI(data.damageAmount)\n            -- ShowDamageVignette()\n        elseif data.targetInstanceId == -1 and data.damageType == "Explosion" then\n            -- Play explosion sound/visual near event source (if position was included in \'data\')\n            print("Nearby explosion!")\n            -- PlayExplosionEffect(data.position)\n    end\nend)\n\n-- Also listen for the status effect event\nlocal statusEffectEvent = NetRay:GetEvent("StatusEffectApplied")\nstatusEffectEvent:OnEvent(function(data)\n    if data.targetName == LocalPlayer.Name then\n        print(("You were afflicted with %s for %d seconds!"):format(data.effect, data.duration))\n        -- Apply visual effect on local player?\n    elseif data.targetName == LocalPlayer.Name then\n        print(("%s was afflicted with %s."):format(data.targetName, data.effect))\n        -- Show indicator on other player\'s nameplate?\n    end\nend)\n'})}),"\n",(0,r.jsx)(n.h3,{id:"firing-events-to-server",children:"Firing Events to Server"}),"\n",(0,r.jsxs)(n.p,{children:["Send events ",(0,r.jsx)(n.em,{children:"to"})," the server using ",(0,r.jsx)(n.code,{children:":FireServer(data)"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- Client Script\nlocal userInputService = game:GetService("UserInputService")\nlocal requestDamageEvent = NetRay:GetEvent("DamageDealt") -- Event server listens to for damage reports\n\nlocal function getTargetInstanceId(target)\n    -- Implement your logic to get a *server-known* ID for the target instance\n    -- Using attributes is a common method\n    return target and target:GetAttribute("InstanceId")\nend\n\nuserInputService.InputBegan:Connect(function(input, gameProcessed)\n    if gameProcessed then return end\n    if input.UserInputType == Enum.UserInputType.MouseButton1 then -- Left click\n        local player = game:GetService("Players").LocalPlayer\n        local mouse = player:GetMouse()\n        local targetInstance = mouse.Target\n        local targetId = getTargetInstanceId(targetInstance) -- Use helper function\n\n        if targetId then\n            print("Attempting to trigger damage event for target ID:", targetId)\n            -- Client tells server it *hit* something. Server validates/calculates damage.\n            requestDamageEvent:FireServer({\n                targetInstanceId = targetId,\n                damageAmount = 10, -- Client might suggest base damage or weapon type\n                damageType = "MeleeSwing"\n            })\n        end\n    end)\nend)\n'})}),"\n",(0,r.jsx)(n.h3,{id:"example-usage",children:"Example Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- Example of event registration\nlocal damageDealtEvent = NetRay:RegisterEvent("DamageDealt", {\n    -- Recommended: Define the data structure for clarity and validation\n    typeDefinition = {\n        targetInstanceId = "number", -- Use a reliable way to identify instances (e.g., custom attribute ID)\n        damageAmount = "number",\n        damageType = "string",\n        position = "Vector3"\n    }\n})\n\n-- Example of firing the event\nlocal target = game.Workspace:FindFirstChild("Target")\ndamageDealtEvent:FireAllClients({\n    targetInstanceId = target:GetAttribute("ID"),\n    damageAmount = 10,\n    damageType = "Physical",\n    position = target.Position\n})\n'})})]})}function g(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var a=t(6540);const r={},i=a.createContext(r);function s(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);