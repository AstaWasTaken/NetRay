"use strict";(self.webpackChunknet_ray_docs=self.webpackChunknet_ray_docs||[]).push([[450],{701:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"advanced-features/optimizations","title":"Optimizations (Batching & Compression)","description":"NetRay incorporates automatic optimizations to improve network efficiency, primarily managed by the internal DynamicSender module.","source":"@site/docs/advanced-features/optimizations.md","sourceDirName":"advanced-features","slug":"/advanced-features/optimizations","permalink":"/NetRay/docs/advanced-features/optimizations","draft":false,"unlisted":false,"editUrl":"https://github.com/AstaWasTaken/NetRay/docs/advanced-features/optimizations.md","tags":[],"version":"current","frontMatter":{"title":"Optimizations (Batching & Compression)"},"sidebar":"docsSidebar","previous":{"title":"Event Priorities","permalink":"/NetRay/docs/advanced-features/priorities"},"next":{"title":"Debugging & Monitoring","permalink":"/NetRay/docs/debugging"}}');var t=i(4848),r=i(8453);const o={title:"Optimizations (Batching & Compression)"},a="Optimizations: Batching & Compression",d={},l=[{value:"1. Event Batching",id:"1-event-batching",level:2},{value:"How it Works",id:"how-it-works",level:3},{value:"Benefits",id:"benefits",level:3},{value:"Configuration",id:"configuration",level:3},{value:"2. Data Compression",id:"2-data-compression",level:2},{value:"How it Works",id:"how-it-works-1",level:3},{value:"Benefits",id:"benefits-1",level:3},{value:"Configuration",id:"configuration-1",level:3},{value:"3. Binary Serialization",id:"3-binary-serialization",level:2},{value:"Benefits",id:"benefits-2",level:3}];function c(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"optimizations-batching--compression",children:"Optimizations: Batching & Compression"})}),"\n",(0,t.jsxs)(n.p,{children:["NetRay incorporates automatic optimizations to improve network efficiency, primarily managed by the internal ",(0,t.jsx)(n.code,{children:"DynamicSender"})," module."]}),"\n",(0,t.jsx)(n.h2,{id:"1-event-batching",children:"1. Event Batching"}),"\n",(0,t.jsx)(n.h3,{id:"how-it-works",children:"How it Works"}),"\n",(0,t.jsxs)(n.p,{children:["When the server sends multiple events to the same client (or group of clients via ",(0,t.jsx)(n.code,{children:"FireAllClients"}),", ",(0,t.jsx)(n.code,{children:"FireFilteredClients"}),") using the same ",(0,t.jsx)(n.code,{children:"RemoteEvent"})," within a short timeframe, NetRay can automatically ",(0,t.jsx)(n.strong,{children:"batch"})," these individual events into a single, larger network packet."]}),"\n",(0,t.jsxs)(n.p,{children:["Instead of firing the underlying ",(0,t.jsx)(n.code,{children:"RemoteEvent"})," multiple times:"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"FireClient(p, data1) -> Network Packet 1"}),"\r\n",(0,t.jsx)(n.code,{children:"FireClient(p, data2) -> Network Packet 2"}),"\r\n",(0,t.jsx)(n.code,{children:"FireClient(p, data3) -> Network Packet 3"})]}),"\n",(0,t.jsxs)(n.p,{children:["NetRay's ",(0,t.jsx)(n.code,{children:"DynamicSender"})," might do this:"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"FireClient(p, data1)"})," -> ",(0,t.jsx)(n.em,{children:"Queued"}),"\r\n",(0,t.jsx)(n.code,{children:"FireClient(p, data2)"})," -> ",(0,t.jsx)(n.em,{children:"Queued"}),"\r\n",(0,t.jsx)(n.code,{children:"FireClient(p, data3)"})," -> ",(0,t.jsx)(n.em,{children:"Queued"})," -> ",(0,t.jsx)(n.em,{children:"Threshold reached or timer expired"})," -> ",(0,t.jsx)(n.code,{children:"InternalFire(p, [data1, data2, data3]) -> Network Packet (Batch)"})]}),"\n",(0,t.jsx)(n.h3,{id:"benefits",children:"Benefits"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reduces Overhead:"})," Each ",(0,t.jsx)(n.code,{children:"RemoteEvent:FireClient"})," or ",(0,t.jsx)(n.code,{children:"FireAllClients"})," call has a small network overhead. Batching significantly reduces this overhead when sending many small, frequent updates (like player position)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Improves Throughput:"})," Sending fewer, larger packets can be more efficient under certain network conditions."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"configuration",children:"Configuration"}),"\n",(0,t.jsx)(n.p,{children:"Batching behavior is controlled by:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"DynamicSender.Config"})," (Internal - in ",(0,t.jsx)(n.code,{children:"Shared/DynamicSender.lua"}),"):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"BatchingEnabled"}),": ",(0,t.jsx)(n.code,{children:"true"})," or ",(0,t.jsx)(n.code,{children:"false"})," to globally enable/disable."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"BatchInterval"}),": How often (seconds) to check pending batches (e.g., ",(0,t.jsx)(n.code,{children:"0.03"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"MaxBatchSize"}),": Max number of events per remote before sending immediately (e.g., ",(0,t.jsx)(n.code,{children:"15"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"MaxBatchWait"}),": Max time (seconds) an event can wait before its batch is sent (e.g., ",(0,t.jsx)(n.code,{children:"0.05"}),")."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"RegisterEvent"})," Option:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"batchable"}),": Set to ",(0,t.jsx)(n.code,{children:"false"})," in event options to ",(0,t.jsx)(n.em,{children:"prevent"})," a specific event type from ever being batched (e.g., for critical, must-be-sent-now events). Default is ",(0,t.jsx)(n.code,{children:"true"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This event might be batched with others of the same type"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'NetRay:RegisterEvent("FrequentUpdate", { batchable = true })\n'})}),"\n",(0,t.jsx)(n.p,{children:"This event will always be sent immediately, never batched"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'NetRay:RegisterEvent("CriticalAlert", { batchable = false })\n'})}),"\n",(0,t.jsx)(n.h2,{id:"2-data-compression",children:"2. Data Compression"}),"\n",(0,t.jsx)(n.h3,{id:"how-it-works-1",children:"How it Works"}),"\n",(0,t.jsxs)(n.p,{children:["NetRay uses the ",(0,t.jsx)(n.code,{children:"DataCompression"})," module (implementing LZW algorithm) via the ",(0,t.jsx)(n.code,{children:"Compressor"})," wrapper to optionally compress payloads before sending them."]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Estimate Size:"})," Before sending, ",(0,t.jsx)(n.code,{children:"DynamicSender"})," estimates the size of the data payload."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Threshold Check:"})," If the estimated size exceeds ",(0,t.jsx)(n.code,{children:"DynamicSender.Config.CompressionThreshold"}),", compression is attempted. Configuration flags like ",(0,t.jsx)(n.code,{children:"ForceCompressBatches"})," can also trigger this."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Compression Attempt:"})," The ",(0,t.jsx)(n.code,{children:"Compressor:Compress"})," function (using ",(0,t.jsx)(n.code,{children:"DataCompression"}),") is called."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Benefit Check:"})," The system compares the size of the ",(0,t.jsx)(n.em,{children:"final serialized compressed data"})," against the size of the ",(0,t.jsx)(n.em,{children:"final serialized original data"}),". It chooses whichever results in a smaller final network packet."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Header Marking:"})," A special marker byte is prepended to the data indicating whether it's compressed and whether it's a single item or a batch."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sending:"})," The chosen payload (original or compressed, serialized to a buffer) is sent."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Receiving:"})," The receiver reads the marker byte, deserializes the payload, and decompresses it if the marker indicates compression was used."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"benefits-1",children:"Benefits"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reduced Bandwidth:"})," Can significantly decrease the amount of data sent over the network, especially for large text-based data or repetitive structures. This saves server bandwidth and can improve experience for players on slower connections."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"configuration-1",children:"Configuration"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"DynamicSender.Config"})," (Internal - in ",(0,t.jsx)(n.code,{children:"Shared/DynamicSender.lua"}),"):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"CompressionThreshold"}),": Estimated byte size to trigger compression attempts (e.g., ",(0,t.jsx)(n.code,{children:"256"}),"). Set to ",(0,t.jsx)(n.code,{children:"0"})," or ",(0,t.jsx)(n.code,{children:"-1"})," to potentially disable threshold-based compression (but ",(0,t.jsx)(n.code,{children:"ForceCompress"})," flags might still apply)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ForceCompressBatches"}),": If ",(0,t.jsx)(n.code,{children:"true"}),", always attempt compression on data marked as a batch."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ForceCompressSingle"}),": If ",(0,t.jsx)(n.code,{children:"true"}),", always attempt compression on single-item sends."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"RegisterEvent"})," / ",(0,t.jsx)(n.code,{children:"RegisterRequestEvent"})," Option:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"compression"}),": ",(0,t.jsx)(n.code,{children:"true"})," or ",(0,t.jsx)(n.code,{children:"false"}),". This acts as a ",(0,t.jsx)(n.em,{children:"hint"}),". If ",(0,t.jsx)(n.code,{children:"true"}),", NetRay is more likely to ",(0,t.jsx)(n.em,{children:"attempt"})," compression even if slightly below the threshold (the final size check still applies). If ",(0,t.jsx)(n.code,{children:"false"}),", compression might be skipped even if above the threshold (depending on ",(0,t.jsx)(n.code,{children:"ForceCompress"})," flags)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["Compression adds CPU overhead on both the sender and receiver. NetRay attempts to only compress when the potential bandwidth saving outweighs the CPU cost, but the effectiveness depends heavily on the ",(0,t.jsx)(n.em,{children:"type"})," of data being sent. Binary data or already compressed data often won't compress well further. Text and repetitive table structures usually benefit most."]})}),"\n",(0,t.jsx)(n.h2,{id:"3-binary-serialization",children:"3. Binary Serialization"}),"\n",(0,t.jsxs)(n.p,{children:["NetRay utilizes a custom binary serialization format (implemented in ",(0,t.jsx)(n.code,{children:"Shared/Serializer.lua"})," and ",(0,t.jsx)(n.code,{children:"Shared/Types/*"}),") instead of relying solely on Roblox's built-in serialization or JSON."]}),"\n",(0,t.jsx)(n.h3,{id:"benefits-2",children:"Benefits"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Efficiency:"})," Custom binary formats can be significantly more compact than general-purpose formats like JSON for Roblox data types (Vector3, CFrame, Color3, etc.) and common Lua types (small integers, booleans)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Type Information:"})," The format inherently includes type identifiers, allowing for precise reconstruction of data types on the receiving end without ambiguity."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This optimization is applied automatically whenever data is sent through NetRay events or requests."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var s=i(6540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);